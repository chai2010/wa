// Auto Generated by https://wa-lang.org/wa/wat2c. DONOT EDIT!!!

#include <stdint.h>
#include <string.h>
#include <math.h>

typedef uint8_t  u8_t;
typedef int8_t   i8_t;
typedef uint16_t u16_t;
typedef int16_t  i16_t;
typedef uint32_t u32_t;
typedef int32_t  i32_t;
typedef uint64_t u64_t;
typedef int64_t  i64_t;
typedef float    f32_t;
typedef double   f64_t;

typedef union val_t {
  i64_t i64;
  f64_t f64;
  i32_t i32;
  f32_t f32;
} val_t;

// func $fib (param $n i64) (result i64)
typedef struct { val_t $R0; } fn_fib_ret_t;
static fn_fib_ret_t fn_fib(val_t n);

#if defined(_MSC_VER)

// Adapted from
// https://github.com/nemequ/portable-snippets/blob/master/builtin/builtin.h

static inline int I64_CLZ(unsigned long long v) {
  unsigned long r = 0;
#if defined(_M_AMD64) || defined(_M_ARM)
  if (_BitScanReverse64(&r, v)) {
    return 63 - r;
  }
#else
  if (_BitScanReverse(&r, (unsigned long)(v >> 32))) {
    return 31 - r;
  } else if (_BitScanReverse(&r, (unsigned long)v)) {
    return 63 - r;
  }
#endif
  return 64;
}

static inline int I32_CLZ(unsigned long v) {
  unsigned long r = 0;
  if (_BitScanReverse(&r, v)) {
    return 31 - r;
  }
  return 32;
}

static inline int I64_CTZ(unsigned long long v) {
  if (!v) {
    return 64;
  }
  unsigned long r = 0;
#if defined(_M_AMD64) || defined(_M_ARM)
  _BitScanForward64(&r, v);
  return (int)r;
#else
  if (_BitScanForward(&r, (unsigned int)(v))) {
    return (int)(r);
  }

  _BitScanForward(&r, (unsigned int)(v >> 32));
  return (int)(r + 32);
#endif
}

static inline int I32_CTZ(unsigned long v) {
  if (!v) {
    return 32;
  }
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return (int)r;
}

#define POPCOUNT_DEFINE_PORTABLE(f_n, T)                            \
  static inline u32 f_n(T x) {                                      \
    x = x - ((x >> 1) & (T) ~(T)0 / 3);                             \
    x = (x & (T) ~(T)0 / 15 * 3) + ((x >> 2) & (T) ~(T)0 / 15 * 3); \
    x = (x + (x >> 4)) & (T) ~(T)0 / 255 * 15;                      \
    return (T)(x * ((T) ~(T)0 / 255)) >> (sizeof(T) - 1) * 8;       \
  }

POPCOUNT_DEFINE_PORTABLE(I32_POPCNT, u32)
POPCOUNT_DEFINE_PORTABLE(I64_POPCNT, u64)

#undef POPCOUNT_DEFINE_PORTABLE

#else // _MSC_VER

#define I32_CLZ(x) ((x) ? __builtin_clz(x) : 32)
#define I64_CLZ(x) ((x) ? __builtin_clzll(x) : 64)
#define I32_CTZ(x) ((x) ? __builtin_ctz(x) : 32)
#define I64_CTZ(x) ((x) ? __builtin_ctzll(x) : 64)
#define I32_POPCNT(x) (__builtin_popcount(x))
#define I64_POPCNT(x) (__builtin_popcountll(x))

#endif // _MSC_VER

#define ROTL(x, y, mask) \
  (((x) << ((y) & (mask))) | ((x) >> (((mask) - (y) + 1) & (mask))))
#define ROTR(x, y, mask) \
  (((x) >> ((y) & (mask))) | ((x) << (((mask) - (y) + 1) & (mask))))

#define I32_ROTL(x, y) ROTL(x, y, 31)
#define I64_ROTL(x, y) ROTL(x, y, 63)
#define I32_ROTR(x, y) ROTR(x, y, 31)
#define I64_ROTR(x, y) ROTR(x, y, 63)

// func fib (param $n i64) (result i64)
static fn_fib_ret_t fn_fib(val_t n) {
  fn_fib_ret_t $result;
  u32_t $R_u32;
  u16_t $R_u16;
  u8_t  $R_u8;
  val_t $R0, $R1, $R2;

  $R0 = n;
  $R1.i64 = 2;
  $R0.i32 = ((u64_t)($R0.i64)<=(u64_t)($R1.i64))? 1: 0;
  if($R0.i32) {
    $R0.i64 = 1;
    $result.$R0 = $R0;
    return $result;
  }
  $R0 = n;
  $R1.i64 = 1;
  $R0.i64 -= $R1.i64;
  {
    fn_fib_ret_t $ret = fn_fib($R0);
    $R0 = $ret.$R0;
  }
  $R1 = n;
  $R2.i64 = 2;
  $R1.i64 -= $R2.i64;
  {
    fn_fib_ret_t $ret = fn_fib($R1);
    $R1 = $ret.$R0;
  }
  $R0.i64 += $R1.i64;
  $result.$R0 = $R0;
  return $result;
}


