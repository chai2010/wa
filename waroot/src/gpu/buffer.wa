
import "js"

type BufferUsage u32

const (
    BufferUsage_MAP_READ:       BufferUsage = 1
    BufferUsage_MAP_WRITE:      BufferUsage = 2
    BufferUsage_COPY_SRC:       BufferUsage = 4
    BufferUsage_COPY_DST:       BufferUsage = 8
    BufferUsage_INDEX:          BufferUsage = 16
    BufferUsage_VERTEX:         BufferUsage = 32
    BufferUsage_UNIFORM:        BufferUsage = 64
    BufferUsage_STORAGE:        BufferUsage = 128
    BufferUsage_INDIRECT:       BufferUsage = 256
    BufferUsage_QUERY_RESOLVE:  BufferUsage = 512
)

type MapState i32

const (
    MapState_unmapped: MapState = iota
    MapState_pending
    MapState_mapped
)

type MapMode i32
const (
    MapMode_READ: MapMode = 1
    MapMode_WRITE: MapMode = 2
)

type BufferDesc struct {
    Label:            string
    MappedAtCreation: bool
    Size:             int
    Usage:            BufferUsage
}

/*
不能使用该类型直接声明值，需通过 Device.CreateBuffer() 创建
*/
type Buffer struct {
    js.ExtObj
    _device: js.ExtObj
    desc: BufferDesc

    mapped: bool
    mappedRange: []byte
}

/*
向Buffer中写入数据块
*/
func Buffer.Write(offset: i32, data: []byte) {
    jsWriteBuffer(this._device.GetHandle(), this.GetHandle(), offset, data)
}
#wa:import webgpu write_buffer
func jsWriteBuffer(device, buffer: js.Handle, offset: i32, data: []byte)

/*
返回 Buffer 的标签
*/
func Buffer.Label() => string {
    return this.desc.Label
}

/*
返回 Buffer 的大小（以字节为单位）
*/
func Buffer.Size() => int {
    return this.desc.Size
}

/*
返回 Buffer 的用途
*/
func Buffer.Usage() => BufferUsage {
    return this.desc.Usage
}

/*
返回 Buffer 的映射状态
*/
func Buffer.MapState() => MapState {
    return jsBufferMapState(this.GetHandle())
}
#wa:import webgpu buffer_map_state
func jsBufferMapState(buffer: js.Handle) => MapState


type BufferMapper interface {
    OnMapped(b: *Buffer, ok: bool)
}

type BufferMapHandler func(b: *Buffer, ok: bool)

/*
异步映射
*/
#wa:generic MapAysncWithHandler
func Buffer.MapAsync(mode: MapMode, mapper: BufferMapper) {
    if mapper == nil {
        panic("BufferMapper can't be nil.")
    }
    tid := asyncTasks.Alloc(this, mapper)
    jsBufferMapAsync(tid, this.GetHandle(), mode)
}

func Buffer.MapAysncWithHandler(mode: MapMode, handler: BufferMapHandler) {
    if handler == nil {
        panic("BufferMapHandler can't be nil.")
    }
    tid := asyncTasks.Alloc(this, handler)
    jsBufferMapAsync(tid, this.GetHandle(), mode)
}
#wa:import webgpu buffer_map_async
func jsBufferMapAsync(tid: int, buffer: js.Handle, mode: MapMode)


/*
获取已映射的 Buffer 的数据块
*/
#wa:generic GetMappedRangeOffset GetMappedRangeOffsetSize
func Buffer.GetMappedRange() => []byte {
    if !this.mapped {
        panic("Not mapped.")
    }
    return this.mappedRange
}

func Buffer.GetMappedRangeOffset(offset: int) => []byte {
    if !this.mapped {
        panic("Not mapped.")
    }

    if offset >= this.desc.Size {
        panic("range overflowed")
    }

    return this.mappedRange[offset:]
}

func Buffer.GetMappedRangeOffsetSize(offset, size: int) => []byte {
    if !this.mapped {
        panic("Not mapped.")
    }

    if offset + size > this.desc.Size {
        panic("range overflowed")
    }

    return this.mappedRange[offset:offset + size]
}

func Buffer.Unmap() {
    if !this.mapped {
        return
    }

    jsBufferUnmap(this.GetHandle(), this.mappedRange)
    this.mapped = false
    this.mappedRange = nil
}
#wa:import webgpu buffer_unmap
func jsBufferUnmap(bh: js.Handle, mappedRange: []byte)

#wa:import webgpu buffer_get_mapped_range
func jsBufferGetMappedRange(buffer: js.Handle) => []byte

#wa:export gpu.onBufferMapped
func onBufferMapped(tid: int, ok: bool, data: []byte) {
    source, handler := asyncTasks.Get(tid)

    buffer := source.(*Buffer)
    buffer.mapped = ok
    buffer.mappedRange = data

    switch h := handler.(type) {
    case BufferMapper:
        h.OnMapped(buffer, ok)

    case BufferMapHandler:
        h(buffer, ok)
    }

    asyncTasks.Free(tid)
}
