// 版权 @2024 凹语言 作者。保留所有权利。

package wat2c

import (
	"fmt"

	"wa-lang.org/wa/internal/wat/token"
)

func (p *wat2cWorker) buildCode() error {
	fmt.Fprintf(&p.c, "// Auto Generated by http://wa-lang.org/wat2c. DONOT EDIT!!!\n\n")

	if p.m.Name != "" {
		fmt.Fprintf(&p.c, "// module %s\n\n", p.m.Name)
	}

	fmt.Fprintf(&p.c, "#include <stdint.h>\n\n")

	if err := p.buildMemory(); err != nil {
		return err
	}
	if err := p.buildTable(); err != nil {
		return err
	}

	if err := p.buildGlobal(); err != nil {
		return err
	}
	if err := p.buildFuncs(); err != nil {
		return err
	}

	return nil
}

func (p *wat2cWorker) buildMemory() error {
	if p.m.Memory == nil {
		return nil
	}
	if p.m.Memory.Name != "" {
		fmt.Fprintf(&p.c, "// memory $%s\n", p.m.Memory.Name)
	}
	if max := p.m.Memory.MaxPages; max > 0 {
		fmt.Fprintf(&p.c, "static uint8_t   wasm_memoy[%d*64*1024];\n", max)
		fmt.Fprintf(&p.c, "static int       wasm_memoy_size = %d;\n", p.m.Memory.Pages)
		fmt.Fprintf(&p.c, "static const int wasm_memoy_max_pages = %d;\n", max)
		fmt.Fprintf(&p.c, "static const int wasm_memoy_pages = %d;\n", p.m.Memory.Pages)
	} else {
		fmt.Fprintf(&p.c, "static uint8_t   wasm_memoy[%d*64*1024];\n", p.m.Memory.Pages)
		fmt.Fprintf(&p.c, "static int       wasm_memoy_size = %d;\n", p.m.Memory.Pages)
		fmt.Fprintf(&p.c, "static const int wasm_memoy_max_pages = %d;\n", p.m.Memory.Pages)
		fmt.Fprintf(&p.c, "static const int wasm_memoy_pages = %d;\n", p.m.Memory.Pages)
	}
	fmt.Fprintln(&p.c)
	return nil
}

func (p *wat2cWorker) buildTable() error {
	if p.m.Table == nil {
		return nil
	}
	if p.m.Table.Type != token.FUNCREF {
		return fmt.Errorf("unsupported table type: %s", p.m.Table.Type)
	}

	if p.m.Table.Name != "" {
		fmt.Fprintf(&p.c, "// table $%s\n", p.m.Table.Name)
	}
	if max := p.m.Table.MaxSize; max > 0 {
		fmt.Fprintf(&p.c, "static uintptr_t wasm_table[%d];\n", max)
		fmt.Fprintf(&p.c, "static int32_t   wasm_table_size = %d;\n", p.m.Table.Size)
		fmt.Fprintf(&p.c, "static const int wasm_table_max_size = %d;\n", max)
	} else {
		fmt.Fprintf(&p.c, "static uintptr_t wasm_table[%d];\n", p.m.Table.Size)
		fmt.Fprintf(&p.c, "static int32_t   wasm_table_size = %d;\n", p.m.Table.Size)
		fmt.Fprintf(&p.c, "static const int wasm_table_max_size = %d;\n", p.m.Table.Size)
	}
	fmt.Fprintln(&p.c)
	return nil
}

func (p *wat2cWorker) buildGlobal() error {
	if len(p.m.Globals) == 0 {
		return nil
	}
	for _, g := range p.m.Globals {
		fmt.Fprintf(&p.c, "// global $%s: %v\n", g.Name, g.Type)
		switch g.Type {
		case token.I32:
			if g.Mutable {
				fmt.Fprintf(&p.c, "static int32_t var_%s = %d;\n", toCName(g.Name), g.I32Value)
			} else {
				fmt.Fprintf(&p.c, "static const int32_t var_%s = %d;\n", toCName(g.Name), g.I32Value)
			}
		case token.I64:
			if g.Mutable {
				fmt.Fprintf(&p.c, "static int64_t var_%s = %d;\n", toCName(g.Name), g.I64Value)
			} else {
				fmt.Fprintf(&p.c, "static const int64_t var_%s = %d;\n", toCName(g.Name), g.I64Value)
			}
		case token.F32:
			if g.Mutable {
				fmt.Fprintf(&p.c, "static float var_%s = %f;\n", toCName(g.Name), g.F32Value)
			} else {
				fmt.Fprintf(&p.c, "static const float var_%s = %f;\n", toCName(g.Name), g.F32Value)
			}
		case token.F64:
			if g.Mutable {
				fmt.Fprintf(&p.c, "static double var_%s = %f;\n", toCName(g.Name), g.F64Value)
			} else {
				fmt.Fprintf(&p.c, "static const double var_%s = %f;\n", toCName(g.Name), g.F64Value)
			}
		default:
			return fmt.Errorf("unsupported global type: %s", g.Type)
		}
	}
	fmt.Fprintln(&p.c)
	return nil
}

func (p *wat2cWorker) buildFuncs() error {
	if len(p.m.Funcs) == 0 {
		return nil
	}

	// 函数声明
	for _, f := range p.m.Funcs {
		fmt.Fprintf(&p.c, "// func $%s", f.Name)
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if x.Name != "" {
					fmt.Fprintf(&p.c, " (param $%s %v)", x.Name, x.Type)
				} else {
					fmt.Fprintf(&p.c, " (param $%d %v)", i, x.Type)
				}
			}
		}
		if len(f.Type.Results) > 0 {
			fmt.Fprintf(&p.c, " (result")
			for _, x := range f.Type.Results {
				fmt.Fprintf(&p.c, " %v", x)
			}
			fmt.Fprint(&p.c, ")")
		}
		fmt.Fprintln(&p.c)

		// 返回值通过栈传递, 返回入栈的个数
		fmt.Fprintf(&p.c, "static int fn_%s(int64_t $result[]", toCName(f.Name))
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if x.Name != "" {
					fmt.Fprintf(&p.c, ", %v %v", toCType(x.Type), toCName(x.Name))
				} else {
					fmt.Fprintf(&p.c, ", %v $arg%d", toCType(x.Type), i)
				}
			}
		}
		fmt.Fprintf(&p.c, ");\n")
	}
	fmt.Fprintln(&p.c)

	// 函数的实现
	for _, f := range p.m.Funcs {
		fmt.Fprintf(&p.c, "// func %s", f.Name)
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if x.Name != "" {
					fmt.Fprintf(&p.c, " (param $%s %v)", x.Name, x.Type)
				} else {
					fmt.Fprintf(&p.c, " (param $%d %v)", i, x.Type)
				}
			}
		}
		if len(f.Type.Results) > 0 {
			fmt.Fprintf(&p.c, " (result")
			for _, x := range f.Type.Results {
				fmt.Fprintf(&p.c, " %v", x)
			}
			fmt.Fprint(&p.c, ")")
		}
		fmt.Fprintln(&p.c)

		// 返回值通过栈传递, 返回入栈的个数
		fmt.Fprintf(&p.c, "static int fn_%s(int64_t $result[]", toCName(f.Name))
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if x.Name != "" {
					fmt.Fprintf(&p.c, ", %v %v", toCType(x.Type), toCName(x.Name))
				} else {
					fmt.Fprintf(&p.c, ", %v $arg%d", toCType(x.Type), i)
				}
			}
		}
		fmt.Fprintf(&p.c, ") {\n")
		if err := p.buildFunc_body(f); err != nil {
			return err
		}
		fmt.Fprintf(&p.c, "}\n\n")
	}

	fmt.Fprintln(&p.c)
	return nil
}
